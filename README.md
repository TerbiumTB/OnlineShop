# Online shop
###### Булагков Тимофей, БПИ 236

## Запуск

Запуск происходит через утилиту `Make`. В Makefile есть следующие коиманды:

- `make build` – собрать проект
- `make construct` - собрать проект с опцией `--no-cache`
- `make run` – запустить собранный проект
- `make stop` – остановить запущенный проект
- `make clean` – остановить запущенный проект и удалить docker volumes

Эти команды являются просто алиасами соответсвующих команд докера. Также есть команды:

- `make rerun` – остановить и запустить заново
- `make start` – собрать и запустить
- `make restart` – остановить, собрать и запустить
- `make fresh` – остановить с удалением volumes, собрать и запустить

В начале для запуска сервера требуется выполнить команду `make start`.

После запуска будет доступна swagger документации:

- http://localhost:8080/docs/ для сервиса заказов
- http://localhost:8081/docs/ для сервиса оплат
## Решение

###### Я опять написал все на Go...

Архитектура приложения следует всем советам из файлика. 
Есть два сервиса (ну и API Gateway) – orders и payments. В первом происходит создание и обработка заказов,
во втором – создание и управление аккаунтов, а также сами платежи. 

Оба сервиса следуют Clean Architecture и структурно очень похожи между собой, 
поэтому опишу только payments, так как он сложнее. 

В папке models находятся доменные сущности – Account, Payment и Event, тут ничего интересного.

Основная логика находится, на самом деле, в инфраструктурном слое. Во-первых, здесь реализовано хранлище аккаунтов. Помимо этого тут находится реализация брокера сообщений. 
Для этого я использовал Kafka, но благодаря интерфейсам можно написать и любой другой. Outbox и Inbox паттерны
реализованы с помощью транзакций PostgreSQL, но чтобы сервис не зависел от конкретной реализации, были написаны интерфейсы
Inboxer, Outboxer (для хранения событий)и Transation, Mananger (для транзакций). Реализация последних по сути является лишь оберткой 
соответсввенных оъектов из библиотеки sqlx.

В сервисном слое есть четыре класса, три из них являются воркерами, запускаемыми в фоновом режиме. 
Это InboxWorker и OutboxWorker, которые осуществляют взаимодействие с брокером сообщений и гарантируют семантику Exactly Once, 
так как при сохранении события используется ID заказа в качестве ключа идемпотентности. Третий воркер – PaymentWorker, пытается совершить все оплаты из inbox событий,
и в случае завершения операции (со статусом FAIL или SUCCESS) передает событие в outbox. AccountService работает как прослойка между контроллерами и репозиторием,
совершая валидацию передаваемых значений.

Контроллеры находятся в папке handlers и лишь отвечают на запросы, вызывая правильные функции AccountService.

Микро-сервис заказов устроен точно так же, но в нем нет InboxWorker (так как для обновления требуется только семантика At Least Once), и есть воркер StatusWorker, 
который периодически обновляет статус заказов. 

Также стоит отметить, что для простоты реализации, прямо сейчас используется не вся мощь кафки, и собтия обрабатываются по одному. Так как все скрыто за интерфейсами, 
реализовать множественную обработку сообщений представляется только делом техники.

